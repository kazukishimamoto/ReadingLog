# 1 章

オブジェクト指向設計についての章。

- 設計とは、将来を予測し仕様やコードを決めることではなく、変化することを受け入れて変更がしやすいコードにするためのもの。
- 設計の評価は難しい。評価を助けるためのメトリクスはあるが、それが良いからといって良い設計になっているとは限らない。
- 手続き型言語は、データとふるまいに隔たりがある。データはある振る舞いから次の振る舞いへと引き渡される（データに対して何でもできる）
- オブジェクト指向言語は、データとふるまいをオブジェクトとしてまとめる。
- 設計の理論を学んでも、ただそれを適用するだけではうまくいかない。実践ではその時の状況に応じて、配られたカードでベストを尽くすこと。

# 2 章 単一責任のクラスを設計する

## クラスやメソッドは単一責任にしましょう

なぜか：責務が1つのクラスは再利用性が高いため、コードの変更が容易になるから
アプリケーションの最終形は予測できるものではなく、常に変化するため変化が容易になるようなコードの設計が重要

### 単一責任になっているかどうかのチェックをする方法は2つ

1. クラスの持つメソッドを質問にしてみる
→ 「Gearクラスさん、あなたの比を教えてくれませんか？」はわかる-
→ 「Gearクラスさん、あなたのタイヤのサイズを教えてくれませんか」は違和感がある

2. そのクラス（メソッド）の説明を1分でしてみる
→ 「それと」や「または」といった言葉が入っている場合、単一責任になっていない可能性が高い

### 設計する時期を適切に見極める

あるクラスに違和感があったとしても、その時が設計を変更する時期とは限らない。
未来にどんな変更があるのかは誰もわからない。であれば、設計は可能な限り送らせて、変更がしやすく保つことが大事。
たとえGearクラスとWheelクラスを2つのクラスに分けられなかったとしても、Gearクラス内にStructでWheelを定義してWheelに関する責務を隔離しておくことができる。
こうすることで、責務を分離しつつ設計の判断を遅らせることができ、Wheelクラスが必要とわかった時点でクラス分けも非常に簡単にできるようになる。

# 3章 依存関係を管理する

依存関係とはなにか…あるオブジェクトに変更を加えたとき、それによって同時に変更しなければならない場合、片方に依存しているオブジェクトがあるということ。

## 依存しているかどうかを認識するポイント
* 他のクラス名を知っている：GearはWheelという名前のクラスが存在すると予想している
→ Wheelというクラス名が変更されたら？Gear内のコードも変更する必要がある
* self以外のどこかに贈ろうとするメッセージの名前：GearはWheelのインスタンスがdiameterに応答すると予想している
→ Wheelのdiameterメソッド名は変更されたら？
* メッセージを要求する引数：GearはWheel.newにrimとtireが必要なことを知っている
→ 引数に変更があったら？
* 引数の順番：GearはWheel.newの最初の引数がrimで２番目がtireであると知っている
→ 引数の順番が変わったら？

それぞれのパターンでWheelに変更があったらGearにも変更が必要になる

依存しているコードの例は以下

```ruby
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end

  def gear_inches
    ratio * Wheel.new(rim, tire).diameter
  end
end
```

## 疎結合にするには

### 依存オブジェクトの注入

Gearクラス内でWheelオブジェクトをnewするのではなく、Gearをnewする際に外からWheelオブジェクトを渡してあげるようにする
こうすることでGearはWheelオブジェクトという他のクラス名を知る必要はなくなる

```ruby
class Gear
  attr_accessor :chaingring, :cog, :wheel
  def def initialize(chainging, cog, wheel)
    @chainging = chainging
    @cog = cog
    @wheel = wheel
  end
end
```

### 依存を隔離する

* インスタンス変数の作成を分離する

Wheel.newをメソッドに切り出してあげることで、Wheelクラスに変更があった際の影響を最小限にできる

* 外部メッセージを隔離する

wheel.diameterのように、self以外に対してメッセージを送る箇所は以下のように隔離してあげることで変更した際に必要な対応を1箇所にすることができる

```ruby
def diameter
  wheel.diameter
end
```

### 引数の順番への依存を取り除く

* 初期化の際の引数にハッシュを使う

引数にハッシュを仕様することで、順番への依存をなくすことができる。
また、ハッシュにするとキー名を書かないといけない煩わしさがあるものの、コードを読んだときに受け取っている引数がなんなのかを表すドキュメント代わりにもなってくれるメリットがある

* デフォルト値を設定する

以下のようにdefaultsを設定しておきmergeする手法がある
```ruby
def initialize(args)
  args = defaults.merge(args)
  @chainrings = args[:chainrings]
  ...
end

def defaults
  { chainrings: 40, cog: 18 }
end
```

* 複数パラメータを用いた初期化を隔離する

対象のclass自身を修正できない場合は、Wrapperを定義することで外部ライブラリなどの複雑なインターフェースを隔離する方法がある
```ruby
module SomeFramework
  class Gear
    attr_accessor :chainring, :cog, :wheel
    def initialize(chainring, cog, wheel)
      @chainring = chainring
      @cog = cog
      @wheel = wheel
    end
  end
end

# Gearが外部ライブラリなどで、変更出来ない場合
module GearWrapper
  def self.gear(args)
    SomeFramework::Gear.new(args[:chainring], args[:cog], args[:wheel])
  end
end

GearWrapper.gear(chainring: 52, cog: 11, wheel: Wheel.new(26, 1.5).gear_inches)
```
