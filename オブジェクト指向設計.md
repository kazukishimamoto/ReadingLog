# 1 章

オブジェクト指向設計についての章。

- 設計とは、将来を予測し仕様やコードを決めることではなく、変化することを受け入れて変更がしやすいコードにするためのもの。
- 設計の評価は難しい。評価を助けるためのメトリクスはあるが、それが良いからといって良い設計になっているとは限らない。
- 手続き型言語は、データとふるまいに隔たりがある。データはある振る舞いから次の振る舞いへと引き渡される（データに対して何でもできる）
- オブジェクト指向言語は、データとふるまいをオブジェクトとしてまとめる。
- 設計の理論を学んでも、ただそれを適用するだけではうまくいかない。実践ではその時の状況に応じて、配られたカードでベストを尽くすこと。

# 2 章 単一責任のクラスを設計する

## クラスやメソッドは単一責任にしましょう

なぜか：責務が1つのクラスは再利用性が高いため、コードの変更が容易になるから
アプリケーションの最終形は予測できるものではなく、常に変化するため変化が容易になるようなコードの設計が重要

### 単一責任になっているかどうかのチェックをする方法は2つ

1. クラスの持つメソッドを質問にしてみる
→ 「Gearクラスさん、あなたの比を教えてくれませんか？」はわかる-
→ 「Gearクラスさん、あなたのタイヤのサイズを教えてくれませんか」は違和感がある

2. そのクラス（メソッド）の説明を1分でしてみる
→ 「それと」や「または」といった言葉が入っている場合、単一責任になっていない可能性が高い

### 設計する時期を適切に見極める

あるクラスに違和感があったとしても、その時が設計を変更する時期とは限らない。
未来にどんな変更があるのかは誰もわからない。であれば、設計は可能な限り送らせて、変更がしやすく保つことが大事。
たとえGearクラスとWheelクラスを2つのクラスに分けられなかったとしても、Gearクラス内にStructでWheelを定義してWheelに関する責務を隔離しておくことができる。
こうすることで、責務を分離しつつ設計の判断を遅らせることができ、Wheelクラスが必要とわかった時点でクラス分けも非常に簡単にできるようになる。

# 3章 依存関係を管理する

依存関係とはなにか…あるオブジェクトに変更を加えたとき、それによって同時に変更しなければならない場合、片方に依存しているオブジェクトがあるということ。

## 依存しているかどうかを認識するポイント
* 他のクラス名を知っている：GearはWheelという名前のクラスが存在すると予想している
→ Wheelというクラス名が変更されたら？Gear内のコードも変更する必要がある
* self以外のどこかに贈ろうとするメッセージの名前：GearはWheelのインスタンスがdiameterに応答すると予想している
→ Wheelのdiameterメソッド名は変更されたら？
* メッセージを要求する引数：GearはWheel.newにrimとtireが必要なことを知っている
→ 引数に変更があったら？
* 引数の順番：GearはWheel.newの最初の引数がrimで２番目がtireであると知っている
→ 引数の順番が変わったら？

それぞれのパターンでWheelに変更があったらGearにも変更が必要になる

## 疎結合にするには

* 依存オブジェクトの注入

```
class Gear
  attr_reader :chainring, :cog, :rim, :tire
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @rim = rim
    @tire = tire
  end
  
  def gear_inches
  end
end
```
Gearクラス内
